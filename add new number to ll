Intuition
Imagine you have a number represented as a linked list, where each node contains a single digit. The first node contains the leftmost digit. Our goal is to add one to this number. This might sound simple, but we need to handle the digit carry-over, just like we do when adding numbers manually. Starting from the rightmost digit makes it easier to manage carry-overs. However, since our linked list starts from the leftmost digit, we need to reverse the list first. This makes it easier to add one from the least significant digit and manage any carry-over.

Approach
Reverse the Linked List: Reverse the linked list so we can start the addition from the rightmost digit.
Add One: Add one to the first digit of the reversed list. If there’s a carry (result is 10), set the current digit to 0 and carry over 1 to the next digit.
Handle the Carry: If there’s still a carry after reaching the end of the list, add a new node with the digit 1.
Reverse Again: Reverse the list again to restore the original order, now with the added value.
Return the New Head: Return the head of the modified linked list.


struct ListNode
{
    int val;
    ListNode *next;
    ListNode()
    {
        val = 0;
        next = NULL;
    }
    ListNode(int data1)
    {
        val = data1;
        next = NULL;
    }
    ListNode(int data1, ListNode *next1)
    {
        val = data1;
        next = next1;
    }
};

class Solution {
public:
    //Function to reverse the linked list
    ListNode* reverseList(ListNode* head) {
        // Initialize pointers
        ListNode* prev = NULL;
        ListNode* current = head;
        ListNode* next = NULL;
        
        while (current != NULL) {
            // Store next node
            next = current->next;
            // Reverse the link
            current->next = prev;
            // Move prev to current
            prev = current;
            // Move current to next
            current = next;
        }
        
        return prev;
    }
    //Function to add one to Linked List
    ListNode *addOne(ListNode *head) {
        //Reverse the linked list
        head = reverseList(head);
        
        //Create a dummy node
        ListNode* current = head;
        //Initialize carry with 1
        int carry = 1;  
        
        while (current != NULL) {
            /*Sum the current node's value 
            and the carry*/
            int sum = current->val + carry;
            //Update carry
            carry = sum / 10;
            //Update the node's value
            current->val = sum % 10;
            
            /*If no carry left
            break the loop*/
            if (carry == 0) {
                break;
            }
            
            /*If we've reached the end of the list
            there's still a carry,
            add a new node with the carry value*/
            if (current->next == NULL && carry != 0) {
                current->next = new ListNode(carry);
                break;
            }
            
            // Move to the next node
            current = current->next;
        }
        
        // Reverse the list 
        head = reverseList(head);
        
        // New head
        return head;
    }
};

//Function to print the linked list
void printList(ListNode* head) {
    while (head != NULL) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    //Creation of Linked List
    ListNode* head1 = new ListNode(1);
    head1->next = new ListNode(2);
    head1->next->next = new ListNode(3);

    //Solution instance
    Solution solution;
    head1 = solution.addOne(head1);
    cout << "Result after adding one: ";
    printList(head1);

    return 0;
}
